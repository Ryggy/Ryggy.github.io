---
layout: post
title: Dino Sim - Procedural Generation
subtitle: There's lots to learn!
gh-repo: JoshuaWMarshall/CreatureFeature
gh-badge: [star, fork, follow]
tags: [dino sim, procedural generation]
comments: true
mathjax: true
author: Ryan Williamson
---

# Understanding Procedural Generation: A Deep Dive into My Unity Project


![Procedural Generation Demo](https://ryggy.github.io/assets/img/procgen.gif)


Procedural generation is a powerful technique used in game development to create content algorithmically rather than manually, allowing for diverse and unique game worlds. In this blog post, I’ll share insights into my journey of implementing procedural generation in a Unity project, detailing the planning process, key references, and how I structured the system. I’ll also touch upon creating a custom editor tool and integrating an in-game UI.

## References
Before diving into the technical aspects, I relied on several resources that guided my understanding and implementation of procedural generation:

1. **IndividualKex. (2022). ProceduralGrid. GitHub.** [GitHub Link](https://github.com/IndividualKex/ProceduralGrid)
2. **Sebastian Lague. (2016, Jan 1). Procedural landmass generation.** [YouTube Video](https://youtu.be/wbpMiKiSKm8?si=mBFpqAb9GFumkWR0)
3. **Wizards Code. (2022, Dec 25). Procedural Placement of Trees in Unity.** [YouTube Video](https://youtu.be/q5KD4KXczys?si=XVAynWHfW1CSDjEp)

These references provided foundational knowledge and practical insights into creating procedural terrains and placing objects within those environments.

## Planning the System
The planning stage involved conceptualising the procedural generation system to achieve a natural and engaging game world. I defined essential parameters, including terrain size, noise scale, and the number of octaves for generating variations in height. The parameters were essential for configuring the noise function that shapes the terrain.


### Key Steps in Terrain Generation

1. **Noise Map Generation**: 
   - I created a noise map using Perlin noise, which allows for smooth height transitions across the terrain. The noise parameters, such as scale and octaves, can be adjusted for different effects.

2. **Vertex Creation**:
   - The terrain mesh is constructed by defining vertices based on the noise map. Each vertex's height is determined by the noise value, allowing for realistic terrain features like hills and valleys.

3. **Triangle Formation**:
   - Triangles are created by connecting the vertices, enabling the mesh to be rendered in Unity. This involves iterating through the vertices and defining the indices for the triangles.

4. **Color Mapping**:
   - The color of each vertex is determined based on its height, using a gradient that transitions from dark (low) to light (high) colors, enhancing the visual appeal of the terrain.

5. **Water Mesh Integration**:
   - A water mesh is instantiated to simulate water bodies on the terrain, with adjustable parameters for height and scale, improving the overall aesthetic of the environment.

6. **Dynamic Updates**:
   - The terrain can be regenerated by destroying the existing mesh and creating a new one based on updated parameters, allowing for infinite variations in the gameplay experience.


### Key Steps in the Tree Placement Process

1. **Initialization**:
   - The script initializes references to essential components, such as `TargetManager` and `GameManager`, to manage the game state and food sources for herbivores.

2. **Tree Placement Data**:
   - It uses a `TreePlacementData` structure to hold parameters for tree placement, including a noise map, maximum steepness, and randomness factors.

3. **Tree Placement Logic**:
   - The script iterates over each vertex of the terrain mesh to assess its suitability for tree placement using a fitness function. 
   - **Fitness Function**: This function evaluates the fitness of each vertex based on:
     - The corresponding value from the noise map.
     - The steepness of the terrain at that vertex.
     - The vertex’s height relative to the water level.
   - If a vertex meets the criteria (e.g., fitness exceeds a certain threshold), a tree is instantiated at that location with a random offset to create a more natural distribution.

4. **Rest Area Placement**:
   - The script also randomly places rest areas near some trees to enhance gameplay dynamics, creating locations for herbivores to gather.

5. **Tree Management**:
   - The system includes methods for clearing the placed trees and rest areas, ensuring that the game state can be reset or modified dynamically.

6. **Serialization**:
   - The `TreePlacementData` structure includes methods to load and save data using Unity's `EditorPrefs`, allowing for easy customization and persistence of tree placement settings.

# DinosaurPlacement Script Process

The **DinosaurPlacement** script is designed to place dinosaurs (Stegosaurus and Velociraptor) in a procedurally generated terrain within a Unity game. It ensures that dinosaurs are positioned in suitable locations based on specific environmental conditions.

## Process

1. **Initialization**:
   - When the game starts, the script initializes references to the `TargetManager` and `GameManager`. The `TargetManager` helps track food sources for carnivorous dinosaurs.

2. **Update Loop**:
   - The script checks every frame if the game has started. If it has, it initializes the carnivore food dictionary to keep track of food sources.

3. **Placing Dinosaurs**:
   - The `PlaceDinos` method is called to spawn the dinosaurs:
     - For each type of dinosaur (Stegosaurus and Velociraptor):
       - It attempts to find a valid position on the terrain using a random vertex.
       - The position is checked for suitability based on two criteria:
         - **Fitness**: This includes checking whether the position is above a certain water height and assessing the steepness of the terrain.
       - If the position is suitable, a dinosaur prefab is instantiated at that location, and it’s added to the corresponding container (either `stegoContainer` or `raptorContainer`).

4. **Clearing Dinosaurs**:
   - The `ClearDinos` method is called to remove all placed dinosaurs from the scene. This method destroys the containers holding the dinosaurs and clears the food dictionary, resetting the environment for a new placement if needed.

5. **Random Vertex Selection**:
   - The script uses a method to select random inner vertices of the terrain mesh while avoiding the edges. This ensures that the dinosaurs are placed within the bounds of the terrain.

6. **Fitness Calculation**:
   - The fitness of a position is calculated based on:
     - **Height above water level**: If below, the position is deemed unsuitable.
     - **Terrain steepness**: If too steep, the position is also considered unsuitable.

## Creating a Custom Editor Tool and In-Game UI

In addition to the procedural generation logic, I developed a custom editor tool to facilitate easy adjustments of parameters like terrain size and noise settings. This editor tool provides sliders and input fields that allow real-time updates to the generated world, enhancing the workflow during development.

Furthermore, an in-game UI was created to display relevant information to the player, such as the number of dinosaurs spawned and the current terrain state. As I was planning on displaying this to non-game developers I wanted to make sure it could be easily used outside of the editor.



